/*
 Problem: 283. Move Zeroes
 Given an integer array nums, move all 0's to the end of it while maintaining 
 the relative order of the non-zero elements. Do this in-place.
 
 Approach:
 - Use two pointers technique:
   - `i` keeps track of the position where the next non-zero element should be placed
   - `j` scans through the array to find non-zero elements
 - When a non-zero element is found at position `j`, swap it with position `i` (if i != j)
 - Increment `i` only when we place a non-zero element
 - This ensures all non-zero elements move to the front in their original order
 
 Time Complexity: O(n)  // Single pass through the array
 Space Complexity: O(1) // In-place manipulation with only constant extra space
 
 Example:
 Input:  [0,1,0,3,12]
 Output: [1,3,12,0,0]
 Process: i=0,j=1 → swap → [1,0,0,3,12], i=1,j=3 → swap → [1,3,0,0,12], i=2,j=4 → swap → [1,3,12,0,0]
*/
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length;
        if (n <= 1) return;
        
        int i = 0; // pointer for non-zero elements position
        for (int j = 0; j < n; j++) {
            if (nums[j] != 0) {
                if (i != j) swap(i, j, nums); // avoid unnecessary swaps
                i++;
            }
        }
    }
    
    private void swap(int i, int j, int[] nums) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    // main method for testing
    public static void main(String[] args) {
        Solution sol = new Solution();
        
        int[] nums1 = {0, 1, 0, 3, 12};
        sol.moveZeroes(nums1);
        System.out.println(java.util.Arrays.toString(nums1)); // [1, 3, 12, 0, 0]
        
        int[] nums2 = {0, 0, 1};
        sol.moveZeroes(nums2);
        System.out.println(java.util.Arrays.toString(nums2)); // [1, 0, 0]
        
        int[] nums3 = {1, 2, 3};
        sol.moveZeroes(nums3);
        System.out.println(java.util.Arrays.toString(nums3)); // [1, 2, 3]
    }
}
