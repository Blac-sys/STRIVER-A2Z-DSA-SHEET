/*
 Problem: 189. Rotate Array
 Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
 
 Approach:
 - Use the "Three Reversals" technique:
   1. Reverse the entire array
   2. Reverse the first k elements
   3. Reverse the remaining n-k elements
 - Handle edge cases: k >= n by using k % n to avoid unnecessary rotations
 - This approach works because reversing twice brings elements to their final positions
 
 Time Complexity: O(n)  // Each element is accessed at most 3 times during reversals
 Space Complexity: O(1) // In-place manipulation using only constant extra space
 
 Example:
 Input:  nums = [1,2,3,4,5,6,7], k = 3
 Step 1: Reverse entire array → [7,6,5,4,3,2,1]
 Step 2: Reverse first k=3 elements → [5,6,7,4,3,2,1]
 Step 3: Reverse remaining elements → [5,6,7,1,2,3,4]
 Output: [5,6,7,1,2,3,4]
*/
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        if (n <= 1) return;
        
        // Handle cases where k >= n
        if (k >= n) k = k % n;
        
        // Three reversals approach
        // Step 1: Reverse the whole array
        reverse(0, n - 1, nums);
        // Step 2: Reverse the first k elements
        reverse(0, k - 1, nums);
        // Step 3: Reverse the remaining elements
        reverse(k, n - 1, nums);
    }
    
    private void reverse(int i, int j, int[] nums) {
        while (i < j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
            i++;
            j--;
        }
    }
    
    // main method for testing
    public static void main(String[] args) {
        Solution sol = new Solution();
        
        int[] nums1 = {1, 2, 3, 4, 5, 6, 7};
        sol.rotate(nums1, 3);
        System.out.println(java.util.Arrays.toString(nums1)); // [5, 6, 7, 1, 2, 3, 4]
        
        int[] nums2 = {-1, -100, 3, 99};
        sol.rotate(nums2, 2);
        System.out.println(java.util.Arrays.toString(nums2)); // [3, 99, -1, -100]
    }
}
